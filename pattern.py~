from parameter import *
import sys
sys.path = [STANFORDPARSERPATH] + sys.path

from parser import Parser
from pymongo import MongoClient
import jpype
from gaia import FileReader

from collections import defaultdict, Counter
from time import time

import json
import pdb
import re

dependencyOrder = {   'amod': 2,
        'dobj': 5,
        'nn':   1,
        'det':  3,
        'npadvmod': 4
        }

dependenciesLabel = {   'amod': 'MN',
        'dobj': 'VO',
        'nn':   'MN',
        'det':  'MN',
        'npadvmod': 'VO'
        }

def toSortDependency(dep):
    if dep[0] in dependencyOrder:
        return dependencyOrder[dep[0]]
    else:
        return 6

class PatternTransformer:
    def __init__(self):
        self.p = Parser()

    def transformToPattern(self, query):
        try:
            dependencies, posTags, queryToks = self.p.parseToStanfordDependencies(query)
        except:
            print 'pattern transformer: parse error, {}'.format(query)
            return '', '', ''
        dependencies = sorted(dependencies, key=toSortDependency)

        labelCount = defaultdict(lambda: 1, {})
        labelSubstrings =  {}

        for index, tag in posTags.iteritems():
            if tag[0].lower() == 'v':
                tmp = 'SV'
            elif tag[0].lower() == 'n':
                tmp = 'SN'

            else:
                continue
            try:
                substring = queryToks[index]
            except:
                return '', '', ''
        
            label = tmp + str(labelCount[tmp])
            labelSubstrings[label] = substring
            labelCount[tmp] += 1

            queryToks[index] = label

        for dep in dependencies:
            if dep[0] in dependenciesLabel:
                for i in range(dep[1], dep[2]+1):
                    if queryToks[i] and queryToks[i] in labelSubstrings:
                        queryToks[i] = labelSubstrings[queryToks[i]]
                substring = ' '.join([tok for tok in queryToks[dep[1]:dep[2]+1] if tok])
                if not substring:
                    continue

                label = dependenciesLabel[dep[0]] + str(labelCount[dep[0]])
                labelSubstrings[label] = substring
                labelCount[dep[0]] += 1
                queryToks[dep[1]:dep[2]+1] = [label] + ['']*(dep[2]-dep[1])

        pattern = ' '.join([tok for tok in queryToks if tok])
        labelSubstrings2 = {}
        for tok in queryToks:
            if tok in labelSubstrings:
                labelSubstrings2[tok] = labelSubstrings[tok]

        return pattern, labelSubstrings2, query

#print PatternTransformer().transformToPattern('hot naked girls sucking fucking dogs')

class TransformQueriesToPattern(FileReader):
    def __init__(self, fname):
        FileReader.__init__(self, fname)
        self.pt = PatternTransformer()
        self.st = time()
        self.fout = open(DATADIR+'patterns', 'w')

    def processLine(self, line):
        try:
            pattern, labelSubstrings, query = self.pt.transformToPattern(line)
        except:
            print line
            return

        if pattern and labelSubstrings:
            onePattern = {}
            onePattern['pattern'] = pattern
            onePattern['label'] = labelSubstrings
            onePattern['query'] = query
            json.dump(onePattern, self.fout)
            self.fout.write('\n')

        if self.lineNum % 10000 == 0:
            print time() - self.st

    def finalize(self):
        self.fout.close()

#print PatternTransformer().transformToPattern('I want to lose weight and eat red meat and sing')
#tqtp = TransformQueriesToPattern(QUERIESFILE)
#tqtp.readLines()

def foo(fname, coreNumber, threadID):
    tqtp = TransformQueriesToPatternMultiThread(fname, coreNumber, threadID)
    tqtp.readLines()

class TransformQueriesToPatternMultiThread(TransformQueriesToPattern):
    def __init__(self, fname, coreNumber, threadID):
        TransformQueriesToPattern.__init__(self, fname)
        self.coreNumber = coreNumber
        self.threadID = threadID

        self.fout.close()
        self.fout = open(DATADIR+'patterns.'+str(coreNumber), 'w')

    def processLine(self, line):
        if self.lineNum % self.coreNumber == self.threadID:
            print line
            TransformQueriesToPattern.processLine(self, line)

    @staticmethod
    def transform(fname, coreNumber):
        from multiprocessing import Process

        processes = [0]*coreNumber
        for i in range(coreNumber):
            processes[i] = Process(target=foo, args=(fname, coreNumber, i, ))
            processes[i].start()

        for i in range(coreNumber):
            processes[i].join()

        import os

        for i in range(coreNumber):
            os.system('cat '+DATADIR+'patterns.'+str(i)+'>> '+DATADIR+'patterns.all')

#TransformQueriesToPatternMultiThread.transform(QUERIESFILE, 8)

def testFindSubtaskByPatternsFromQueries(query='lose weight'):
    patterns = Patterns(DATADIR+'100Patterns')
    candidateQueries = findCandidateQueries(query)

    subtasks = patterns.findSubtasks(candidateQueries)
    return subtasks

#testFindSubtaskByPatternsFromQueries()

class CandidateQuery:
    def __init__(self, data):
        self.queryPattern = data['pattern']
        self.labelSubstrings = data['label']
        self.query = data['query']
        self.toks = self.queryPattern.split(' ')

class Patterns:
    def __init__(self, fname):
        self.patterns = self.loadPatterns(fname)

    def loadPatterns(self, fname):
        fin = open(fname, 'r')
        pats = json.load(fin)
        patterns = (Pattern(pat) for pat in pats)

        fin.close()
        return patterns

    def findSubtasks(self, candidateQueries):
        subtasks = Counter()
        for pattern in self.patterns:
            subtasks += Counter(pattern.findSubtasks(candidateQueries))

        return [element[0] for element in subtasks.most_common(20)]

class Pattern:
    def __init__(self, data):
        self.text = data[0]
        self.toks = self.text.split(' ')
        self.subtaskLabel = data[1]
        self.TIndex = self.toks.index('T')

    def findSubtasks(self, candidateQueries):
        subtasks = (cq.labelSubstrings[self.subtaskLabel] for cq in candidateQueries if self.match(cq))
        return subtasks

    def match(self, candidateQuery):
        if self.TIndex < len(candidateQuery.toks) and candidateQuery.toks[self.TIndex][:2] in ('VO', 'SV'):
            tmp = candidateQuery.toks[:]
            tmp[self.TIndex] = 'T'
            return self.text in ' '.join(tmp)
        return False

def findCandidateQueries(query):
    mc = MongoClient()
    db = mc['query']
    collectionName = 'candQ'

    results = db.command('text', collectionName, search=query, project={'pattern': 1, 'label': 1, 'query': 1}, limit=1000000)
    
    candidateQueries = (CandidateQuery(result['obj']) for result in results['results'])
    return candidateQueries

class TSUBTAndQueryToPattern:
    def test(self):
        query = 'losing much weights by herbs'
        tsubt = ['lose weight', ['sport', 'herb']]

        mc = MongoClient()
        db = mc['test']
        collectionName = 'test'

        db[collectionName].drop()

        pt = PatternTransformer()
        pattern, label, query = pt.transformToPattern(query)
        from nltk import PorterStemmer
        ps = PorterStemmer()

        VO, nonVO = [], []
        for k in label:
            toks = label[k].split()
            label[k] = ' '.join([ps.stem(word) for word in toks])
            if k[:2] == 'VO':
                toks = label[k].split()
                VO.append('{} {}'.format(toks[0], toks[-1]))

            else:
                nonVO.append(label[k])

        record = {'pattern': pattern, 'label': label, 'query': query, '4search': ' '.join(VO+nonVO)}
        print json.dumps(record)
        #record = json.loads("{pattern: u'VO1 by SN2', _id: ObjectId('56381b7d5837ff7aae574942'), 4search: u'lose weight herb', query: 'losing much weights by herbs', label: {SN2: u'herb', VO1: u'lose much weight'}}")
        db[collectionName].insert_one(record)
        db[collectionName].create_index([('4search', 'text')])

        
        self.db = db
        self.col = db[collectionName]

        queries = self.findQueriesByTSUBT(tsubt)
        pattern = self.transformToPatterns(tsubt, queries)[0]

        assert pattern['pattern'] == 'T by SUBT'
        assert pattern['label']['T'] == 'lose much weight'
        assert pattern['label']['SUBT'] == 'herb'

    #@profile
    def findQueriesByTSUBT(self, tsubt):
        # task contains only V and O
        # subtasks are terms, V or O, both stemmed
        task, subtasks = tsubt
        
        # candQ: {pattern: '...', label: {...}, query: '...', '4search': '...'}
        # text index in 4search, which is like 'lose weight eat fruit'(from query 'losing lots of  weight by eating fruit')
        # words in label and 4search stemmed
        query = '\"{}\" {}'.format(task, ' '.join(subtasks))
        results = self.db.command('text', self.col.name, search=query, project={'pattern':1, 'label':1, 'query':1}, limit=1000000)
        candQueries = [result['obj'] for result in results['results']]
        return candQueries

    #@profile
    def transformToPatterns(self, tsubt, queries):
        task, subtasks = tsubt
        tasktoks = task.split()
        taskpat = re.compile(r'^{}.*{}$'.format(tasktoks[0], tasktoks[1]))

        for i in xrange(len(queries)):
            labels = queries[i]['label']
            hasTaskNotReplaced, hasSubtaskNotReplaced = True, True
            for label, substring in labels.iteritems():
                if not (hasTaskNotReplaced or hasSubtaskNotReplaced):
                    break

                if hasTaskNotReplaced and taskpat.match(substring):
                    queries[i] = self.replaceLabel(queries[i], label, substring, 'T')
                    hasTaskNotReplaced = False

                if hasSubtaskNotReplaced:
                    for subtask in subtasks:
                        if subtask in substring:
                            queries[i] = self.replaceLabel(queries[i], label, substring, 'SUBT')
                            hasSubtaskNotReplaced = False
                            break

        return queries

    #@profile
    def replaceLabel(self, query, label, substring, newLabel):
        del query['label'][label]
        query['label'][newLabel] = substring
        query['pattern'] = query['pattern'].replace(label, newLabel)
        return query
        
a=TSUBTAndQueryToPattern()
a.test()
